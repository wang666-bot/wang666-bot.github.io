<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>智能Bi项目笔记 | Hyrule</title><meta name="author" content="Ivey"><meta name="copyright" content="Ivey"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="BI商业智能： 数据可视化、报表可视化效果 传统BI平台：  需要人工上传数据  需要人工托选分析要用到的数据行和列  需要人工选择图表类型   生成图表   智能BI平台： 区别于传统的BI，用户只需要导入最原始的数据集，输入想要进行分析的目标，就能利用AI生成一个符合要求的图表以及结论 需求分析： 1.智能分析：用户输入目标和原始数据（图表类型），可以字段生成图标和分析结论 2.图标管理 3.">
<meta property="og:type" content="article">
<meta property="og:title" content="智能Bi项目笔记">
<meta property="og:url" content="https://wang666-bot.github.io/266ed923.html">
<meta property="og:site_name" content="Hyrule">
<meta property="og:description" content="BI商业智能： 数据可视化、报表可视化效果 传统BI平台：  需要人工上传数据  需要人工托选分析要用到的数据行和列  需要人工选择图表类型   生成图表   智能BI平台： 区别于传统的BI，用户只需要导入最原始的数据集，输入想要进行分析的目标，就能利用AI生成一个符合要求的图表以及结论 需求分析： 1.智能分析：用户输入目标和原始数据（图表类型），可以字段生成图标和分析结论 2.图标管理 3.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.google.com/url?sa=i&url=https%3A%2F%2Fforum.gamer.com.tw%2FG2.php%3Fbsn%3D60539%26sn%3D3216&psig=AOvVaw2fiuMuiGyB89xLYbvWzaYx&ust=1690401754556000&source=images&cd=vfe&opi=89978449&ved=0CA0QjRxqFwoTCJjkxrXTqoADFQAAAAAdAAAAABAD">
<meta property="article:published_time" content="2023-06-20T02:43:50.000Z">
<meta property="article:modified_time" content="2023-06-20T02:50:40.558Z">
<meta property="article:author" content="Ivey">
<meta property="article:tag" content="Java开发 Bi分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.google.com/url?sa=i&url=https%3A%2F%2Fforum.gamer.com.tw%2FG2.php%3Fbsn%3D60539%26sn%3D3216&psig=AOvVaw2fiuMuiGyB89xLYbvWzaYx&ust=1690401754556000&source=images&cd=vfe&opi=89978449&ved=0CA0QjRxqFwoTCJjkxrXTqoADFQAAAAAdAAAAABAD"><link rel="shortcut icon" href="/wang666-bot.github.io/img/favicon.png"><link rel="canonical" href="https://wang666-bot.github.io/266ed923.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/wang666-bot.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/wang666-bot.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '智能Bi项目笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-20 10:50:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fforum.gamer.com.tw%2FG2.php%3Fbsn%3D60539%26sn%3D3216&amp;psig=AOvVaw2fiuMuiGyB89xLYbvWzaYx&amp;ust=1690401754556000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CA0QjRxqFwoTCJjkxrXTqoADFQAAAAAdAAAAABAD" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/wang666-bot.github.io/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/wang666-bot.github.io/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/wang666-bot.github.io/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/wang666-bot.github.io/" title="Hyrule"><span class="site-name">Hyrule</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">智能Bi项目笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-20T02:43:50.000Z" title="发表于 2023-06-20 10:43:50">2023-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-20T02:50:40.558Z" title="更新于 2023-06-20 10:50:40">2023-06-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="智能Bi项目笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>BI商业智能： 数据可视化、报表可视化效果</p>
<p>传统BI平台：</p>
<ol>
<li><p>需要人工上传数据</p>
</li>
<li><p>需要人工托选分析要用到的数据行和列</p>
</li>
<li><p>需要人工选择图表类型 </p>
</li>
<li><p>生成图表</p>
</li>
</ol>
<p>智能BI平台：</p>
<p>区别于传统的BI，用户只需要导入最原始的数据集，输入想要进行分析的目标，就能利用AI生成一个符合要求的图表以及结论</p>
<p>需求分析：</p>
<p>1.智能分析：用户输入目标和原始数据（图表类型），可以字段生成图标和分析结论</p>
<p>2.图标管理</p>
<p>3.图表生成的异步化（消息队列）</p>
<p>4.对接AI能力</p>
<p>架构图</p>
<img src="/wang666-bot.github.io/post/266ed923.htm/boke/Blog/source/_posts/智能Bi项目笔记/image-20230525212759901.png">

<p><img src="/wang666-bot.github.io/post/266ed923.htm/%E6%99%BA%E8%83%BDBi%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/image-20230525212759901.png" alt="image-20230525212759901"></p>
<p><img src="/wang666-bot.github.io/post/266ed923.htm/%E6%99%BA%E8%83%BDBi%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/image-20230525213340151.png" alt="image-20230525213340151"></p>
<p>技术栈：</p>
<p>前端</p>
<p>​	1.React</p>
<p>​	2.Umi + Ant Design Pro</p>
<p>​	3.可视化开发库（Echarts）</p>
<p>​	4.umi openai 代码生成（自动生成后端调用代码）</p>
<p>后端</p>
<p>​	1.Spring Boot</p>
<p>​	2.MySQL数据库</p>
<p>​	3.MyBatis Plus数据访问框架</p>
<p>​	4.消息队列（RabbitMQ）</p>
<p>​	5.AI能力（Open AI接口开发 &#x2F; 提供现成的AI接口）</p>
<p>​	6.Excel的上传和数据的解析（Easy Excel）</p>
<p>​	7.Swagger +Knife4j（项目接口文档）</p>
<p>​	8.Hutool工具库</p>
<h1 id="5-25"><a href="#5-25" class="headerlink" title="5.25"></a>5.25</h1><p>前端项目初始化</p>
<p>后端项目初始化</p>
<p>前端开发</p>
<p>​	快速开发登录功能</p>
<p>​	图表分析页面的开发</p>
<p>​	图标管理页面的开发</p>
<p>后端开发</p>
<p>​	库表设计</p>
<p>​	图标管理开发</p>
<p>​	文件上传接口开发</p>
<p>前后端业务流程跑通</p>
<h2 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id           <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;id&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    userAccount  <span class="type">varchar</span>(<span class="number">256</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">    userPassword <span class="type">varchar</span>(<span class="number">512</span>)                           <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">    userName     <span class="type">varchar</span>(<span class="number">256</span>)                           <span class="keyword">null</span> comment <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">    userAvatar   <span class="type">varchar</span>(<span class="number">1024</span>)                          <span class="keyword">null</span> comment <span class="string">&#x27;用户头像&#x27;</span>,</span><br><span class="line">    userRole     <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">default</span> <span class="string">&#x27;user&#x27;</span>            <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户角色：user/admin&#x27;</span>,</span><br><span class="line">    createTime   datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime   datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    isDelete     tinyint      <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除&#x27;</span>,</span><br><span class="line">    index idx_unionId (unionId)</span><br><span class="line">) comment <span class="string">&#x27;用户&#x27;</span> <span class="keyword">collate</span> <span class="operator">=</span> utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">--图标信息表chart</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> chart</span><br><span class="line">(</span><br><span class="line">    id           <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;id&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    goal         text   <span class="keyword">null</span>  comment  <span class="string">&#x27;分析目标&#x27;</span>,</span><br><span class="line">    chartData    text   <span class="keyword">null</span>  comment  <span class="string">&#x27;图表数据&#x27;</span>,</span><br><span class="line">    chartType    <span class="type">varchar</span>(<span class="number">128</span>)  <span class="keyword">null</span>   comment  <span class="string">&#x27;图表类型&#x27;</span>,</span><br><span class="line">    genChart     text   <span class="keyword">null</span>   comment  <span class="string">&#x27;生成的图表数据&#x27;</span>,</span><br><span class="line">    genResult    text   <span class="keyword">null</span>   comment  <span class="string">&#x27;生成的分析结论&#x27;</span>,</span><br><span class="line">    userId       <span class="type">bigint</span> <span class="keyword">null</span>   comment <span class="string">&#x27;创建用户id&#x27;</span>  ,</span><br><span class="line">    createTime   datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime   datetime     <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    isDelete     tinyint      <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除&#x27;</span>,</span><br><span class="line">) comment <span class="string">&#x27;图标信息表&#x27;</span> <span class="keyword">collate</span> <span class="operator">=</span> utf8mb4_unicode_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>自动生成后端增删改查代码</p>
<p>1.建表</p>
<p>2.mybatisX插件生成代码</p>
<p>3.迁移生成的代码</p>
<p>4.复制老的增删改查模板，根据新的表重构</p>
<p>5.根据接口文档来测试</p>
<p>前端调用后端</p>
<p>前端更改对应的请求地址：在app.tsx里修改baseURL</p>
<h2 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h2><p>1.前置准备</p>
<p>2.开发登录、注册页面</p>
<p>3.学习使用AI生成BI图标的完整流程（梳理功能点和工作）</p>
<p>4.开发智能分析功能</p>
<p>​	文件上传（前后端）</p>
<p>​	Excel处理</p>
<p>5.图表管理功能</p>
<h3 id="初始化项目-开发前准备"><a href="#初始化项目-开发前准备" class="headerlink" title="初始化项目-开发前准备"></a>初始化项目-开发前准备</h3><p>前端初始化的优化</p>
<p>.husky提交代码时，检查是否规范</p>
<p>1.修改端口</p>
<p>2.删除mock数据（因为本地有后端）</p>
<p>3.替换logo</p>
<p>4.删除国际化locales目录</p>
<p>5.删除测试相关目录</p>
<p>6.prettier、eslint、editorConfig、stylelint，需要开启prettier美化配置</p>
<p>7.替换网站标题：全局替换 Ant Design Pro和Ant Design</p>
<p>开发登陆注册页面</p>
<p>先删掉不需要的，再根据后端去做调整（和后端联调）</p>
<p>如果登陆后还是没法进入页面，修改全局请求配置app.tsx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const request = &#123;</span><br><span class="line">  baseURL: &quot;http://localhost:8101&quot;,</span><br><span class="line">  withCredentials: true,</span><br><span class="line">  ...errorConfig,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改requestErrorConfig文件，可以自定义全局请求响应拦截器</p>
<p>注册页面的开发参考 用户中心项目</p>
<h2 id="智能分析业务开发"><a href="#智能分析业务开发" class="headerlink" title="智能分析业务开发"></a>智能分析业务开发</h2><p>业务流程</p>
<p>​	1.用户输入</p>
<p>​		a.分析目标</p>
<p>​		b.上传原始数据（excel）</p>
<p>​		c.更精细地控制图表：比如图表类型、图标名称等</p>
<p>​	2.后端校验</p>
<p>​		a.校验用户地输入是否合法（比如长度）</p>
<p>​		b.成本控制（次数统计和校验、鉴权等）</p>
<p>​	3.把处理后地数据输入到AI模型（调用AI接口，），让AI模型给我们提供图表信息、结论文本</p>
<p>​	4.图表信息（是一段json配置，是一段代码）、结论文本在前端进行展示</p>
<p>开发接口</p>
<p>根据用户的输入（文本和文件），最后返回图表信息和结论文本</p>
<p>给chart表补充name字段</p>
<p>原始数据压缩</p>
<p>AI接口普遍都有输入字数限制，尽可能压缩数据，能够允许多传几行数据</p>
<p>如何向AI提词（prompt）？</p>
<p>AI提词技巧 1：持续输入，持续优化</p>
<p>AI提词技巧 2：数据压缩（提取关键词）</p>
<p>使用csv对excel文件的数据进行提取和压缩</p>
<p>Easy Excel</p>
<p>一步一步来，先读出数据</p>
<p><img src="/wang666-bot.github.io/post/266ed923.htm/%E6%99%BA%E8%83%BDBi%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/image-20230605194352972.png" alt="image-20230605194352972"></p>
<p>调用AI</p>
<p>输入：</p>
<p>系统预设（提前告诉他职责、功能、回复格式要求）+ 分析目标 + 压缩后的数据</p>
<p>最简单的系统预设：你是一个数据分析师，接下来我会给你应变片受力的最原始的数据和分析目标，请告诉我关于应变片受力情况的分析结论</p>
<p><img src="/wang666-bot.github.io/post/266ed923.htm/%E6%99%BA%E8%83%BDBi%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/image-20230605202137843.png" alt="image-20230605202137843"></p>
<p>AI题词技巧3：在系统（模型）层面做预设效果一般来说，会比直接拼接在用户消息里效果更好一些</p>
<p>AI提词技巧4：除了系统预设外，额外关联一问一答两条消息，相当于给AI一个提示</p>
<h2 id="6-6"><a href="#6-6" class="headerlink" title="6.6"></a>6.6</h2><p>1.跑通整个智能分析功能的业务流程</p>
<p>​		后端</p>
<p>​		前端</p>
<p>2.开发图表管理功能</p>
<p>3.系统优化</p>
<p>智能分析业务流程开发</p>
<p>生成结论</p>
<p>生成图表</p>
<p>AI 无法直接生成现成的图表，但是AI可以生成代码 &#x3D;&gt; 可以把代码利用前端的组件库（Echarts）在网页进行展示</p>
<p>预期生成的图表代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">150</span>, <span class="number">230</span>, <span class="number">224</span>, <span class="number">218</span>, <span class="number">135</span>, <span class="number">147</span>, <span class="number">260</span>],</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="AI提问技巧"><a href="#AI提问技巧" class="headerlink" title="AI提问技巧"></a>AI提问技巧</h2><p>严格控制提问词</p>
<p>0）使用系统预设</p>
<p>1）控制输入格式（便于AI精确地理解我们地需求）</p>
<p>2）控制输出格式（便于AI返回的内容能够更加方便地为我们所用）</p>
<p>3）指定一个示例问答， one-shot问答</p>
<p>3种调用AI的方式</p>
<p>1.直接调用OpenAI或者其他AI原始大模型官网的接口</p>
<p>1）在请求头中指定OPENAI_API_KEY</p>
<p>Authorization: Bearer OPEN_API_KEY</p>
<p>2）找到要使用的接口，比如AI对话接口</p>
<p>3）按照</p>
<p>本质上OpenAI就是提供Http接口</p>
<p>2.使用云服务商提供的，封装后的AI接口</p>
<p>3.利用平台AI提供的开放SDK</p>
<p>智能接口实现</p>
<p>1.构造用户请求（用户消息、csv数据、图表类型等）</p>
<p>2.调用sdk，得到AI响应结果</p>
<p>3.从响应结果中，得出需要的信息，</p>
<p>4.保存图表到数据库</p>
<p>前端开发</p>
<p>输入表单</p>
<p>文件上传时，注意取出原始对象</p>
<p>生成的图表</p>
<p>使用echarts for react</p>
<h2 id="6-7"><a href="#6-7" class="headerlink" title="6.7"></a>6.7</h2><p>1.开发图表管理功能</p>
<p>2.优化系统</p>
<p>开发图表管理功能（增删改查）</p>
<p>后端：复用springboot-init初始化模板的增删改查代码，核心：获取个人创建的图表列表</p>
<p>listMyChartByPage</p>
<p>前端：</p>
<p>​	1.开发一个列表页</p>
<p>​	2.支持按照图表名称搜索</p>
<p>​	</p>
<p>步骤：</p>
<p>1.创建路由和页面</p>
<p>2.获取需要的数据，定义state变量来存储数据，用于给页面展示</p>
<p>3.先把最简单直观的数据展示给前端，再去调样式</p>
<p>4.引入Ant Design 的List组件复制示例代码</p>
<p>5.调整List组件中的内容为自己的（注意，获取用户头像可以从初始化状态中获取）</p>
<p>6.针对样式，对数据做一些处理，比如统一隐藏图标自身的title</p>
<p>7.增加分页</p>
<p>8.增加搜索框</p>
<p>9.其他效果，比如loading效果</p>
<p>小知识：</p>
<p>1.原子化CSS</p>
<p>2.利用F12控制台进行弱网测试</p>
<p>安全性</p>
<p>如果用户上传一个超大的文件怎么办？</p>
<p>只要涉及到用户自主上传的操作，一定要校验文件（图像）</p>
<p>校验的维度：	</p>
<p>​	文件的大小</p>
<p>​	文件的后缀</p>
<p>​	文件的内容（成本较高）</p>
<p>​	文件的合规性（比如敏感内容，建议用第三方的审核功能）</p>
<p>扩展点：接入腾讯云的图片万象数据审核（COS对象存储的审核功能）</p>
<p>数据存储</p>
<p>现状：把每个图表的原始数据全部存放在同一个数据表（chart表）的字段里，</p>
<p>问题：</p>
<p>​	1.如果用户上传的原始数据量很大、图表数日益增多，查询Chart表就会很慢</p>
<p>​	2.对于BI平台，用户是有查看原始数据、对原始数据进行简单查询的需求的，现在如果把所有数据都放在一个字段（列）中，查询时只能取出这个列的所有内容</p>
<p>解决方案 &#x3D;&gt; 分库分表：</p>
<p>​	把每个图表对应的原始数据单独保存为一个新的数据表，而不是一个都存在一个字段里</p>
<p>这样，</p>
<p>​	存储时，能够分开存储，互不影响（也能增加安全性）</p>
<p>​	查询时，可以使用各种sql语句灵活取出需要的字段，查询性能更快</p>
<p>实现：</p>
<p>分开存储：</p>
<p>​	1.存储图标信息时，不把数据存储为字段，而是新建一个chart_{图表id}的数据表</p>
<p>​	通过图表id、数据列名、数据类型等字段，生成以下SQL语句，并且执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- auto-generated definition</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chart_12213141414141</span><br><span class="line">&#123;</span><br><span class="line">	日期 <span class="type">int</span> <span class="keyword">null</span>,</span><br><span class="line">	用户数 <span class="type">int</span> <span class="keyword">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分开查询：</p>
<p>1.以前直接查询图表，取chartData字段，现在改为读取chart_{图表id}的数据表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> chart_12213141414141</span><br></pre></td></tr></table></figure>

<p>具体实现：MyBatis的动态SQL（根据代码灵活地动态生成）</p>
<p>1.想清楚哪些是需要动态替换的，比如要查询的数据表名</p>
<p>2.在mapper.xml中定义sql语句</p>
<p>以下这种方式最灵活，但是要小心sql注入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;queryChartData&quot; parameterType<span class="operator">=</span>&quot;string&quot; resultType<span class="operator">=</span>&quot;map&quot;<span class="operator">&gt;</span></span><br><span class="line">       $&#123;querySql&#125;</span><br><span class="line">   <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>在ChartMapper中定义方法，方法名和上一步的select的id相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; queryChartData(String querySql);</span><br></pre></td></tr></table></figure>

<p>sql注入：select * from chart_12345 where id &#x3D; 1 or 1 &#x3D; 1</p>
<p>测试调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">chartId</span> <span class="operator">=</span> <span class="string">&quot;1665616911881228290&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">querySql</span> <span class="operator">=</span> String.format(<span class="string">&quot;select * from chart_%s&quot;</span>,chartId);</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; result = chartMapper.queryChartData(querySql);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>分库分表</p>
<p>​	水平分表</p>
<p>​	垂直分库</p>
<p>根据实际的业务场景和技术架构情况，综合考虑各种因素来选择适合自己的分库分表策略</p>
<p>限流</p>
<p>现在的问题：使用系统是需要消耗成本的，用户有可能疯狂刷量</p>
<p>解决问题：</p>
<p>​	1. 控制成本 &#x3D; &gt; 限制用户调用总次数</p>
<p>​	2.用户在短时间内疯狂使用，导致服务器资源被占满，其他用户无法使用 &#x3D;&gt; 限流</p>
<p>思考限流阈值多大合适？参考正常用户的使用， 比如限制单个用户在每秒只能使用1次</p>
<p>限流的几种算法</p>
<p>1）固定窗口限流</p>
<p>单位时间内允许部分操作</p>
<p>1小时只允许10个用户操作</p>
<p>优点：简单</p>
<p>缺点：可能出现流量突刺，前59分钟无操作，第59来了十个操作，第1小时01分钟来了十个操作，相当于2分钟来了20个操作，服务器仍有高峰危险</p>
<p>2）滑动窗口限流</p>
<p>单位时间内允许部分操作，但是这个单位时间是滑动的，需要指定一个滑动单位</p>
<p>优点：能够解决上述流量突刺的问题，只要还在这个窗口内，更多的操作就会被拒绝</p>
<p>缺点：实现相对复杂，限流效果和滑动单位有关，滑动单位越小，限流效果越好，但往往很难选到一个特别合适的滑动单位</p>
<p>3）漏桶限流（推荐）</p>
<p>以固定速率处理请求，当请求桶满了后，拒绝请求</p>
<p>每秒处理10个请求，桶的容量是10，每0.1秒固定处理一次请求，如果1秒内来了10个请求，都可以处理完，但如果1秒内来了11个请求，最后那个请求就会溢出桶被拒绝</p>
<p>优点：能够一定程度上应对流量突刺，能够<strong>固定速率处理请求</strong>，保证服务器的安全</p>
<p>缺点：没有办法迅速处理一批请求，只能一个一个按顺序来处理（固定速率的缺点）</p>
<p>4）令牌桶限流（推荐）</p>
<p>管理员先生成一批令牌，每秒生成10个令牌，当用户要执行操作前，先去拿到一个令牌，有令牌的人就有资格执行操作、能够同时执行操作，拿不到令牌的就等着</p>
<p>优点：能够并发处理同时的请求，<strong>并发性能会更好</strong></p>
<p>缺点：还是存在是按单位的选取问题</p>
<p>限流粒度</p>
<p>1.针对某个方法限流，即最多允许同时xx个操作使用该方法</p>
<p>2.针对某个用户限流，比如单个用户单位时间内最多执行xx个操作</p>
<p>3..针对某个用户x方法限流</p>
<p>限流的实现</p>
<p>1）本地限流（单机限流）</p>
<p>每个服务器单独限流，一般是适用于单体项目，就是项目只有一个服务器</p>
<p>Guava RateLimiter</p>
<p>2）分布式限流（多机限流）</p>
<p>如果项目有多个服务器，比如微服务，建议使用分布式限流</p>
<p>1.把用户的使用频率的等数据放到一个集中的存储进行统计，比如Redis，这样无论用户的请求落到了哪台服务器，都以集中的数据存储内的数据为准（Redisson-是一个操作Redis的工具库，伙伴匹配系统）</p>
<p>2.在网关集中进行限流和统计（比如Sentinel、Spring Cloud Gateway）</p>
<p>Redisson限流实现</p>
<p>Redisson内置了一个限流工具类，可以帮助利用Redis实现</p>
<p>RedisLimiterManager：什么是Manager？专门提供RedisLimiter限流基础服务的  （提供了通用的能力）</p>
<p>6.16</p>
<p>业务流程分析</p>
<p>问题：</p>
<p>​	1.图表生成时间过长，AI能力需要一定时间来完成处理</p>
<p>​	2.当系统面临大量用户请求时，如果处理能力有限，可能会导致用户处在一个长时间的等待状态。特别是当许多用户同时提交</p>
<p>​	3.当我们调用第三方服务，比如我们的AI处理能力有限，大量用户同时请求可能导致AI过载，甚至拒绝请求</p>
<p>标准异步化的业务流程（服务处理能力有限，或者接口处理时长较长时，就应该考虑采用异步化）</p>
<p>同步：一件事情做完，再做另外一件事情</p>
<p>异步：在处理一件事情的同时，可以处理另外一件事情</p>
<p>业务流程分析</p>
<p>标准异步化的业务流程</p>
<p>1.当用户要进行耗时很长的操作时，点击提交后，不需要在界面傻等，而是应该把这个任务保存到数据库中记录下来</p>
<p>2.用户执行新任务时</p>
<p>​		a.任务提交成功</p>
<p>​			i. 如果我们的程序还有多余的空闲线程，可以立刻去做这个任务</p>
<p>​			ii. 如果我们的程序的线程都在繁忙，无法继续处理，那就放到等待队列里</p>
<p>​		b. 任务提交失败，比如我们的程序所有线程都在忙，任务队列满了</p>
<p>​			i.拒绝这个任务，再也不执行</p>
<p>​			ii.通过保存到数据库中的记录来看到提交失败的任务，并且在任务闲的时候，可以把任务从数据库中捞到程序里，再去执行</p>
<p>3.我们的程序（线程）从任务队列中取出任务依次执行，每完成一件事情后要修改一下任务的状态</p>
<p>4.用户可以查询任务的执行状态，或者在任务执行或失败时能得到通知（发邮件、系统消息提示、短信），从而优化操作</p>
<p>5.如果我们要执行的任务非常复杂，包含很多环节，在每一个小任务完成时，要在程序（数据库中）记录以下任务的执行状态（进度）</p>
<p>标准异步化的业务流程</p>
<p>​	1.用户点击智能分析页的提交按钮时，先把图表立刻保存到数据库中（作为一个任务）</p>
<p>​	2.用户可以在图表管理页面查看所有图表（已生成的、生成中的、生成失败）的信息和状态</p>
<p>问题：</p>
<p>​	1.任务队列的最大容量应该设置为多少？</p>
<p>​	2.程序怎么从任务队列中取出任务去执行？这个任务队列的流程怎么实现？怎么保证程序最多同时执行多少个任务？</p>
<p><strong>线程池</strong></p>
<p>为什么需要线程池？</p>
<p>​	1.线程的管理比较复杂（比如什么时候新增线程，什么时候减少空闲线程）</p>
<p>​	2.任务存取比较复杂（什么时候接收任务，什么时候拒绝任务，怎么保证大家不抢到同一个任务）</p>
<p>线程池的作用：帮助轻松管理线程、协调任务的执行过程</p>
<p>线程池的实现</p>
<p>不需要自己写，如果是在Spring中，可以用ThreadPoolTaskExecutor配合@Async注解来实现（不建议）</p>
<p>如果是在Java中，可以使用JUC并发编程包中的ThreadPoolExecutor来实现非常灵活的自定义线程池</p>
<p>线程池参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br></pre></td></tr></table></figure>

<p>怎么确定线程池参数？结合实际业务场景和系统资源（实际情况）来测试调整，不断优化</p>
<p>回归到我们的业务，系统最脆弱的环节（系统的瓶颈）在哪里？</p>
<p>现有条件：比如AI生成能力的并发只允许4个线程同时去执行，AI能力运行20个任务排队</p>
<p>corePoolSize （核心线程数 &#x3D;&gt; 正式员工数）：正常情况下，我们的系统应该能同时工作的线程数（随时就绪的状态）</p>
<p>maximumPoolSize（最大线程数 &#x3D;&gt; 哪怕任务再多，也最多招这些人）：极限情况下，我们的线程池最多能有多少个线程？</p>
<p>keepAliveTime（空闲线程存活时间）：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工），从而释放无用的线程资源</p>
<p>TimeUnit unit（空闲线程存活时间的单位）：分钟、秒</p>
<p>workQueue（工作队列）：用于存放给线程执行的任务，存在一个队列的长度（一定要设置，不能说队列长度无限，因为也会占用资源）</p>
<p>threadFactory（线程工厂）：控制每个线程的生成、线程的属性（比如线程名）</p>
<p>RejectedExecutionHandler（拒绝策略）：任务队列满的时候，我们采取什么措施，比如抛异常、不抛异常、自定义策略</p>
<p>资源隔离策略：比如重要的任务（VIP任务）一个队列，普通任务一个队列，保证这两个队列互不干扰</p>
<p>一般情况下，任务分为IO密集型和计算密集型两种</p>
<p>计算密集型：吃CPU，比如音视频处理、图像处理、数学计算等，一般是设置corePoolSize为CPU的核数+1（空余线程）</p>
<p>可以让每个线程都能利用好CPU的每个核，而且线程之间不用频繁切换（减少打架、减少开销）</p>
<p>IO密集型：吃带宽&#x2F;内存&#x2F;硬盘的读写资源，corePoolSize可以设置大一点，一般经验值是2n左右，但是建议以IO的能力为主</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>定义线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutorConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="meta">@NotNull</span> Runnable r)</span> &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;线程&quot;</span> + count);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>), threadFactory);</span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>提交任务到线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;任务执行中：&quot;</span> + name + <span class="string">&quot;，执行人&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">          &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, threadPoolExecutor);</span><br></pre></td></tr></table></figure>



<p>开发</p>
<p>实现工作流程</p>
<p>1.给chart表新增任务状态字段（比如排队中、执行中、已完成、失败），任务执行信息字段（用于记录任务执行中，或者失败的一些信息）</p>
<p>2.用户点击智能分析页的提交按钮时，先把图表立刻保存到数据库中（作为一个任务），然后提交任务</p>
<p>3.任务：先修改图表任务状态为“执行中”，等执行成功后，修改为“已完成”，保存执行结果，执行失败后，状态修改为“失败”，记录任务失败信息</p>
<p>4.用户可以在图标管理页面查看所有图表（已生成的、生成中的、生成失败）的信息和状态</p>
<p>5.用户可以修改生成失败的图表信息、点击重新生成</p>
<p>库表设计</p>
<p>chart新增字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">status      <span class="type">varchar</span>(<span class="number">128</span>)   <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;wait&#x27;</span> comment <span class="string">&#x27;wait, running, succeed, failed&#x27;</span>,</span><br><span class="line">execMessage   text      <span class="keyword">null</span>  comment <span class="string">&#x27;执行信息&#x27;</span>,</span><br></pre></td></tr></table></figure>





<p>任务执行逻辑</p>
<p>先修改任务状态为执行中，减少重复执行的风险，同时让用户知道任务执行的状态</p>
<p>前端开发</p>
<p>1.复制一个异步创建图表页面</p>
<p>2.修改以下调用的接口为异步接口</p>
<p>3.移除无用元素和变量</p>
<p>4.修改成功后的操作，比如提示语和重置表单</p>
<p>5.调整我的图表页面，补充错误的处理</p>
<p>6.调整图表的查询顺序，按照创建时间降序</p>
<p>优化点</p>
<p>1.guava Retrying重试机制</p>
<p>2.更精确的提前考虑AI生成错误的情况，在后端进行异常处理（比如AI说了多余的话，提取正确的字符串）</p>
<p>3.如果说任务根本没提交到队列中（或者队列满了），是不是可以用定时任务把失败状态的图表放到队列中（补偿）</p>
<p>4.建议给任务的执行增加一个超时时间，超时后自动标记为失败（超时控制）</p>
<p>5.反向压力：通过调用的服务状态来选择当前系统的策略（比如根据AI服务的当前任务队列数来控制系统的核心线程数），从而最大化利用系统资源</p>
<p>6.我的图表页面增加一个刷新、定时自动刷新的按钮，保证获取到页面的最新状态（前端轮询）</p>
<p>7.任务执行成功或者失败，给用户发送实时消息通知（实时：websocket、 server side event）</p>
<h2 id="6-17"><a href="#6-17" class="headerlink" title="6.17"></a>6.17</h2><p>1.分析系统的现状 （不足）</p>
<p>2.入门分布式消息队列</p>
<p>3.RabbitMQ入门实战</p>
<p>4.项目拓展</p>
<h3 id="分析系统现在的不足（单机系统的不足）"><a href="#分析系统现在的不足（单机系统的不足）" class="headerlink" title="分析系统现在的不足（单机系统的不足）"></a>分析系统现在的不足（单机系统的不足）</h3><p>同步到异步的改造</p>
<p>现状：目前的异步是通过本地的线程池实现的</p>
<p>1）无法集中限制，只能单机限制</p>
<p>例如AI服务限制只能有2个用户同时使用，单个线程池可以i西安至最大核心线程数为2来实现</p>
<p>假设系统用量增大，改为分布式，多台服务器，每个服务器都要有2个线程池，就可能有2N个线程，超过了AI服务的限制</p>
<p>解决方案：在一个集中的地方去管理下发任务（比如集中存储当前正在执行的任务数）</p>
<p>2）任务由于是放在内存中执行的，可能会丢失</p>
<p>虽然可以人工从数据库捞出来再重试，但是需要额外开发（比如定时任务），这种重试的场景是非常典型的，其实是不需要我们开发者过于关心，或者自己实现的</p>
<p>解决方案：把任务放在一个可以持久化存储的硬盘</p>
<p>3）优化：如果系统的功能越来越多，长耗时任务越来越多，系统越来越复杂（比如要开多个线程池、资源可能会出现相互抢占）</p>
<p>服务拆分（应用解耦）：其实我们可以把长耗时、消耗很多资源的任务抽出来把它单独抽成一个程序，不影响主业务</p>
<p>解决方案：可以有一个中间人，让中间人帮我们去连接两个系统（比如核心系统和智能生成业务）</p>
<p>分布式消息队列</p>
<p>中间件（连接多个系统，帮助多个系统紧密协作的技术&#x2F;组件）</p>
<p>Redis、消息队列、分布式存储Etcd</p>
<p>消息队列</p>
<p>存放消息的队列</p>
<p>队列的特点：先进先出</p>
<p>关键词：存储、消息、队列</p>
<p>存储：存数据</p>
<p>消息：某种数据结构，比如字符串、对象、二进制数据、json等等</p>
<p>队列：先进先出的数据结构</p>
<p>消息队列是特殊的数据库么？</p>
<p>可以这么理解</p>
<p>应用场景（作用）：在多个不同的系统、应用之间实现消息的传输（也可以存储），不需要考虑传输应用的编程语言、系统、框架等等</p>
<p>可以让java开发的应用发消息，让php开发的应用收消息，这样就不用把所有代码写到同一个项目里（应用解耦）</p>
<p>消息队列的模型</p>
<p>生产者：Producer，类比快递员，发送消息的人（客户端）</p>
<p>消费者：Consumer，类比为取快递的人，接受读取消息的人（客户端）</p>
<p>消息：Message，类比为快递，就是生产者要传输给消费者的数据</p>
<p>消息队列：Queue，类比为快递柜，存放消息</p>
<p>为什么不直接传输，要用消息队列？生产者不用关系消费者要不要消费，什么时候消费，只需要把东西给消息队列，工作就算完成</p>
<p>生产者和消费者实现了解耦，互不影响</p>
<p>为什么要用消息队列</p>
<p>1）异步处理</p>
<p>生产者发送完消息之后，就可以继续去忙别的，消费者想什么时候消费都可以，不会产生阻塞</p>
<p>2）消峰填谷</p>
<p>先把用户的请求放到消息队列中，消费者（实际执行操作的应用）可以按照自己的需求，慢慢去取</p>
<p>原本：12点时来了10万个请求，原本情况下，10万个请求都在系统内部立刻处理，很快系统压力过大就宕机了</p>
<p>现在：把这10万个请求都放到消息队列中，处理系统以自己的恒定速率（比如每秒1个）慢慢执行，从而保护系统、稳定处理</p>
<p>分布式消息队列的优势</p>
<p>1）.数据持久化：它可以把消息集中存储到硬盘里，服务器重启就不会丢失</p>
<p>2）.可拓展性：可以根据需求，随时增加（或减少）节点，继续保持稳定的服务</p>
<p>3）.应用解耦：可以连接各个不同语言、框架开发的系统，让这些系统能够灵活的传输读取数据</p>
<p>应用解耦的优点：</p>
<p>​	以前，把所有功能都放到同一个项目中，调用多个子功能时，一个环节错，系统就整体出错</p>
<p>使用消息队列进行解耦：</p>
<p>​			1.一个系统挂了，不影响另外一个系统</p>
<p>​			2.系统挂了并恢复后，仍然可以取出消息，继续执行业务逻辑</p>
<p>​			3.只要发送消息到队列，就可以立刻返回，不用同步调用所有系统，性能更高</p>
<p>4）.发布订阅：</p>
<p>如果一个非常大的系统要给其他子系统发送通知，最简单直接的方式是大系统直接一次调用小系统</p>
<p>​	问题：</p>
<p>​		1.每次发通知都要调用很多系统，很麻烦，有可能失败</p>
<p>​		2.新出现的项目（或者说大项目感知不到的项目）无法得到通知</p>
<p>​	解决方案：大的核心系统始终王一个地方（消息队列）去发送消息，其他的系统都去订阅这个消息队列（读取整个消息	队列中的消息）</p>
<p>应用场景</p>
<p>1.耗时的场景（异步）</p>
<p>2.高并发场景（异步、削峰填谷）</p>
<p>3.分布式系统协作（尤其是跨团队、跨业务协作，应用解耦）</p>
<p>4.强稳定性的场景（比如金融业务，持久化、可靠性、削峰填谷）</p>
<p>消息队列的缺点</p>
<p>要给系统引入额外的中间件，系统会更复杂、额外维护中间件、额外的费用（部署）成本</p>
<p>消息队列：消息丢失、顺序性、重复消费、数据的一致性（分布式系统就要考虑）</p>
<p>​	（分布式场景下需要考虑的问题）</p>
<p>主流分布式消息队列选型</p>
<p>主流技术</p>
<p>1.activemq</p>
<p>2.rabbitmq</p>
<p>3.kafka</p>
<p>4.rocketmq</p>
<p>5.zeromq</p>
<p>6.pulsar</p>
<p>7.Apache Inlong（Tube）</p>
<p>技术对比</p>
<p>技术选型指标：</p>
<p>​	吞吐量：IO、并发</p>
<p>​	时效性：类似延迟，消息的发送，到达时间</p>
<p>​	可用性：系统可用的比率（比如一年365天宕机1s）</p>
<p>​	可靠性：消息不丢失，功能正常完成</p>
<table>
<thead>
<tr>
<th>技术名称</th>
<th>吞吐量</th>
<th>时效性</th>
<th>可用性</th>
<th>可靠性</th>
<th>优势</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>activemq</td>
<td>万级</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>简单易学</td>
<td>中小型企业、项目</td>
</tr>
<tr>
<td>rabbitmq</td>
<td>万级</td>
<td><strong>极高（微秒级别）</strong></td>
<td>高</td>
<td>高</td>
<td>生态好、时效性高、易学</td>
<td>绝大多数分布式的应用</td>
</tr>
<tr>
<td>kafka</td>
<td><strong>10万级</strong></td>
<td>高（毫秒级别）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大、可靠性、可用性、可拓展性很高，强大的数据流能力</td>
<td>适用于大规模处理数据的场景，比如构建日志收集系统，实时数据流传输、事件流收集传输</td>
</tr>
<tr>
<td>rocketmq</td>
<td>10万级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大、可靠性、可用性、可拓展性</td>
<td>适用于金融、电商等对可靠性要求较高的场景，适合大规模的消息处理</td>
</tr>
<tr>
<td>pulsar</td>
<td>10万级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>可靠性、可用性、基于发布订阅模型，新兴（技术架构先进）</td>
<td>适合大规模、高并发的分布式系统（云原生），适合实时分析、事件流处理、IoT数据处理等</td>
</tr>
</tbody></table>
<p>RabbitMQ入门实战</p>
<p>特点：生态好，好学习，易于理解，时效性强，支持很多不同语言的客户端，拓展性，可用性都很不错</p>
<p>学习性价比非常高的消息队列，适用于绝大多数中小规模分布式系统</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p>
<p>基本概念</p>
<p>AMQP协议：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a></p>
<p>高级消息队列协议（Advanced Message Queue Protocol）</p>
<p>生产者：发消息到某个交换机</p>
<p>消费者：从某个队列中取消息</p>
<p>交换机（Exchange）：负责把消息<strong>转发</strong>到对应的队列</p>
<p>队列（Queue）：存储消息的</p>
<p>路由（Routes）：转发，就是把消息从一个地方转到另外一个地方（比如从生产者转发到某个队列）</p>
<p>安装：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-windows.html">https://www.rabbitmq.com/install-windows.html</a></p>
<p>先安装erlang（因为RabbitMQ依赖erlang），性能非常高：<a target="_blank" rel="noopener" href="https://www.erlang.org/patches/otp-25.3.2">https://www.erlang.org/patches/otp-25.3.2</a></p>
<p>服务菜单显示正在运行，即安装成功</p>
<p>想要远程访问rabbitmq管理面板，需要自己创建一个管理员密码，否则会被拦截</p>
<p>快速入门：</p>
<p>MQ官方教程</p>
<h3 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h3><p>HelloWorld</p>
<p>引入消息队列Java客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.17.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>生产者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel频道：理解为客户端client（比如jdbcClient，redisClient），提供了和消息队列server建立通信的传输方法（为了复用连接，提高传输效率），程序通过channel操作rabbitmq（比如收发消息）</p>
<p>创建消息队列：</p>
<p>参数：</p>
<p>queueName：消息队列名称（注意：同名称的消息队列，只能用同样的参数创造一次）</p>
<p>durable：消息队列重启后，消息是否丢失</p>
<p>exclusive：是否只允许当前这个创建消息队列的连接操作消息队列</p>
<p>autoDelete：没有人用队列后，是否要删除队列</p>
<p>消费者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动消费者后，可以看到消息被消费了</p>
<h3 id="多消费者"><a href="#多消费者" class="headerlink" title="多消费者"></a>多消费者</h3><p>场景：一个生产者给一个队列发消息，<strong>多个消费者</strong>从这个队列去消息，1对多</p>
<p>多个机器同时去接受并处理任务（尤其是每个机器的处理能力有限）</p>
<p>1）队列持久化<br>durable参数设置为true，服务器重启后队列不丢失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<p>2）消息持久化</p>
<p>指定MessageProperties.PERSISTENT_TEXT_PLAIN参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">                       MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                       message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>



<p>生产者代码（使用scanner方便测试）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;multi_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">                 <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">                channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">                            MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                            message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>控制单个消费者的处理任务积压数</p>
<p>每个消费者最多同时处理一个任务数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p>消费确认机制：为了保证消息成功被消费（快递被成功取走），rabbitmq提供了消息确认机制，当消费者接收到消息后，比如要给一个反馈：</p>
<p>​	ack：消费成功</p>
<p>​	nack：消费失败</p>
<p>​	reject：拒绝</p>
<p>如果告诉rabbitmq服务器消费成功，服务器才会放心的移除消息</p>
<p>支持配置autoack，会自动执行ack命令，接收到消息立刻就成功了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(TASK_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<p>建议autoack改为false，根据实际情况改为手动确认</p>
<p>指定确认某条消息：</p>
<p>第二个参数multiple， 批量确认：是指是否要一次性确认所有的历史消息直到当前这条</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br></pre></td></tr></table></figure>

<p>指定拒绝某些消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br></pre></td></tr></table></figure>

<p>第三个参数标识是否重新入队，可用于重试</p>
<p>消费者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;multi_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//定义如何处理消息</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finali</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理工作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span>  + <span class="string">&quot;编号&quot;</span> + finali + <span class="string">&quot;:&quot;</span>+ message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="comment">//停20s，模拟机器处理能力有限</span></span><br><span class="line">                    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Done&quot;</span>);</span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//开启消费监听</span></span><br><span class="line">            channel.basicConsume(TASK_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>小技巧：</p>
<p>​	1.使用Scannner接受用户输入，便于快速发送多条消息</p>
<p>​	2.使用for循环创建多个消费者，便于快速验证队列模型工作机制</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>场景：多个机器同时去接受并处理任务（尤其是每个机器的处理能力有限）</p>
<p>一个生产者给<strong>多个队列</strong>发送消息，<strong>多个消费者</strong>从这个队列取消息</p>
<p>交换机的作用：类似于网络路由器，提供转发功能。</p>
<p>要解决的问题：怎么把消息转发到不同的队列上，好让消费者从不同的队列消费</p>
<p>绑定：交换机和队列关联起来，也可以叫路由，算是一个算法或者转发策略</p>
<p>绑定代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, &quot;绑定规则&quot;);</span><br></pre></td></tr></table></figure>





<p>交换机的类别：direct 、 topic 、 headers and fanout</p>
<p>fanout交换机：扇出，广播</p>
<p>场景：很适用于发布订阅的场景，比如写日志，可以多个系统间共享</p>
<p>特点：消息会被转发到所有绑定到该交换机的队列</p>
<p>生产者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">        <span class="comment">//创建交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<p>注意，</p>
<p>​	1.消费者和生产者要绑定同一个交换机</p>
<p>​	2。要先有队列才能绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConsumer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel2</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">    <span class="comment">//创建队列，随机分配一个队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;queue2&quot;</span>;</span><br><span class="line">    channel2.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel2.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [1] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot; [2] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    channel2.basicConsume(queueName2, <span class="literal">true</span>, deliverCallback2, consumerTag -&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：所有的消费者都能收到消息</p>
<h2 id="6-18"><a href="#6-18" class="headerlink" title="6.18"></a>6.18</h2><p>Direct交换机</p>
<p>绑定：可以让交换机和队列进行关联，可以指定让交换机把什么样的消息发送给哪个队列（类似于计算机网络中两个路由器，或者网络设备相互连接，也可以理解为网线）</p>
<p>routingKey：路由键，控制消息要转发给哪个队列（IP地址），可以绑定同样的路由键</p>
<p>特点：消息会根据路由键转发给指定的队列</p>
<p>场景：特定的消息只交给特定的系统（程序）来处理</p>
<p>绑定关系：完全匹配路由键</p>
<p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(strings.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Sent to&#x27;&quot;</span> + routingKey + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.mq;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列，随机分配一个队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;queue1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;queue2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [1] Received &#x27;&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [2] Received &#x27;&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback1, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.basicConsume(queueName2, <span class="literal">true</span>, deliverCallback2, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="topic交换机"><a href="#topic交换机" class="headerlink" title="topic交换机"></a>topic交换机</h3><p>特点：消息会根据一个<strong>模糊的</strong>路由键转发到特定的队列</p>
<p>场景：特定的一类消息可以交给特定的一类系统（程序）来处理</p>
<p>绑定关系：可以模糊匹配多个绑定</p>
<ul>
<li>*：匹配一个单词，比如 *.orange ，那么a.orange、b.orange都能匹配</li>
<li>#：匹配0个或多个单词，比如a.#，那么a.a，a.b，a.a.a都能匹配</li>
</ul>
<p>注意，这里的匹配和MySQL的like和%不一样，只能按照单词来匹配，每个’.’分隔单词，如果是’#.’，那么可以忽略，匹配0个单词也ok</p>
<p>生产者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent to&#x27;&quot;</span> + routingKey + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建队列，随机分配一个队列名称</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;frontend_queue&quot;</span>;</span><br><span class="line">      channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;#.前端.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;backend_queue&quot;</span>;</span><br><span class="line">      channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      channel.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;#.后端.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">queueName3</span> <span class="operator">=</span> <span class="string">&quot;product_queue&quot;</span>;</span><br><span class="line">      channel.queueDeclare(queueName3, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      channel.queueBind(queueName3, EXCHANGE_NAME, <span class="string">&quot;#.产品.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [A] Received &#x27;&quot;</span> +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback1, consumerTag -&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot; [B] Received &#x27;&quot;</span> +</span><br><span class="line">              delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName2, <span class="literal">true</span>, deliverCallback2, consumerTag -&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback3</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot; [C] Received &#x27;&quot;</span> +</span><br><span class="line">              delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName3, <span class="literal">true</span>, deliverCallback3, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>支持用消息队列来模拟RPC的调用，但是一般没必要，直接用Dubbo、GRPC等RPC框架就好了</p>
<p>实现一个场景总有更合适的、更专注的技术</p>
<h3 id="Headers交换机"><a href="#Headers交换机" class="headerlink" title="Headers交换机"></a>Headers交换机</h3><p>类似主题和直接交换机，可以根据headers中的内容来指定发送到哪个队列（由于性能差，比较复杂，一般不推荐使用）</p>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><h3 id="消息过期机制"><a href="#消息过期机制" class="headerlink" title="消息过期机制"></a>消息过期机制</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/ttl.html">https://www.rabbitmq.com/ttl.html</a></p>
<p>可以给每条消息指定一个有效期，一段时间内未被消费者处理，就过期了</p>
<p>示例场景：消费者（库存系统）挂了，一个订单15分钟还没被库存系统处理，这个订单其实已经失效了，哪怕库存系统再回复，其实也不用扣库存</p>
<p>适用场景：清理过期队列、模拟延迟队列的实现、专门让某个程序处理过期请求</p>
<p>1）给队列中的消息指定过期时间</p>
<p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ttl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ttl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//创建队列，指定消息过期参数</span></span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">//args指定参数</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line">        <span class="comment">//定义了如何处理消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消费消息，会持续阻塞</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果再过期时间内，还没有消费者取消息，消息才会过期</p>
<p>注意，如果消息已经接受了，但是没确认，是不会过期的</p>
<p>如果消息处于待消费状态并且过期时间到达后，消费会被标记为过期。但是如果消息已经被消费者消费，并且再处理过程中，即使过期时间到达，消息仍然会被正常处理</p>
<p>2）给某条消息指定过期时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">            <span class="comment">//给消息指定过期时间</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder()</span><br><span class="line">                    .expiration(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/confirms.html">https://www.rabbitmq.com/confirms.html</a></p>
<p>上文以阐述过，在第二个交换机模型中</p>
<p>一般情况下autoack改为false</p>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/dlx.html">https://www.rabbitmq.com/dlx.html</a></p>
<p>为了保证消息的可靠性，比如每条消息都成功消费，需要提供一个容错机制，即：失败的消息怎么处理？</p>
<p>死信：过期的消息、拒收的消息、消息队列满了、处理失败的消息的统称</p>
<p>死信队列：专门处理死信的队列（注意，就是一个普通的队列，只不过是专门用来处理死信的，甚至可以理解这个队列的名称叫“死信队列”）</p>
<p>死信交换机：专门给死信队列转发消息的交换机（注意，就是一个普通的交换机，只不过是专门给死信队列发消息而已，理解为这个交换机的名称就叫“死信交换机”），也存在路由绑定关系</p>
<p>死信可以提供死信交换机绑定到死信队列</p>
<p>实现：</p>
<p>​	1.创建死信交换机和死信队列，并且绑定关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明死信交换机</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明死信队列</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;A_dlx_queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;B_dlx_queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;B&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	2.给失败之后需要容错处理的队列绑定死信交换机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列，随机分配一个队列名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queueA&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args2);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;queueA&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	3.可以给要容错的队列指定死信之后的转发规则，死信应该再转发到哪个死信队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定死信要转发到哪个死信队列</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	4.可以通过程序来读取死信队列中的消息，从而进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建队列，随机分配一个队列名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queueA&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args2);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;queueA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;queueB&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">channel.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;queueB&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//拒绝消息</span></span><br><span class="line">channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; [1] Received &#x27;&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; [2] Received &#x27;&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.basicConsume(queueName, <span class="literal">false</span>, deliverCallback1, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line"> channel.basicConsume(queueName2, <span class="literal">false</span>, deliverCallback2, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlxDirectProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;dlx_direct_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct2_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">//声明死信交换机</span></span><br><span class="line">            channel.exchangeDeclare(DEAD_EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明死信队列</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;A_dlx_queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(queueName, DEAD_EXCHANGE_NAME, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;B_dlx_queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(queueName2, DEAD_EXCHANGE_NAME, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(strings.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Sent to&#x27;&quot;</span> + routingKey + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlxDirectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;dlx_direct_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct2_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//指定死信队列参数</span></span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">//要绑定到哪个交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">        <span class="comment">//指定死信要转发到哪个死信队列</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; args2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        args2.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">        args2.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列，随机分配一个队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queueA&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args2);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;queueA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;queueB&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">        channel.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;queueB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//拒绝消息</span></span><br><span class="line">            channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [1] Received &#x27;&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [2] Received &#x27;&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">false</span>, deliverCallback1, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.basicConsume(queueName2, <span class="literal">false</span>, deliverCallback2, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="RabbitMQ的重要特性（面试考点）"><a href="#RabbitMQ的重要特性（面试考点）" class="headerlink" title="RabbitMQ的重要特性（面试考点）"></a>RabbitMQ的重要特性（面试考点）</h2><p>1.消息队列的概念、模型、应用场景</p>
<p>2.交换机的类别、路由绑定的关系</p>
<p>3.消息可靠性</p>
<p>​		a.消息确认机制（ack、nack、reject）</p>
<p>​		b.消息持久化（durable）</p>
<p>​		c.消息过期机制</p>
<p>​		d.死信队列</p>
<p>4.延迟队列（类似死信队列）</p>
<p>5.顺序消费、消费幂等性</p>
<p>6.可拓展性（了解）</p>
<p>​	a.集群</p>
<p>​	b.故障的恢复机制</p>
<p>​	c.镜像</p>
<p>7.运维监控告警（仅作了解）</p>
<h2 id="RabbitMQ项目实战"><a href="#RabbitMQ项目实战" class="headerlink" title="RabbitMQ项目实战"></a>RabbitMQ项目实战</h2><h3 id="选择客户端"><a href="#选择客户端" class="headerlink" title="选择客户端"></a>选择客户端</h3><p>怎么再项目中使用RabbitMQ？</p>
<p>​	1.使用官方的客户端（优点：兼容性好，换语言成本低，比较灵活；缺点：太灵活，要自己去处理一些事情，比如要自	己维护管理链接）</p>
<p>​	2.使用封装好的客户端，比如Spring Boot RabbitMQ Starter（优点：简单易用，直接配置直接用；缺点：有一定的学习	门槛，不够灵活，被框架限制）</p>
<p>根据场景来选择，没有绝对的优劣</p>
<p>本次使用第二种方法</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>注意，使用的版本一定要和项目中的springboot版本一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在yml中引入配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spirng:</span><br><span class="line">rabbitmq:</span><br><span class="line">   host: localhost</span><br><span class="line">   post: 5672</span><br><span class="line">   password: guest</span><br><span class="line">   username: guest</span><br></pre></td></tr></table></figure>



<p>首次启动，创建交换机和队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建测试程序用到的交换机和队列（只需要执行一次）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqInitMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_exchange&quot;</span>;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建队列，随机分配一个队列名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;code_queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;my_routingKey&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>引入生产者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, String message)</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入消费者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&#125;, ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> deliverTag)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;receiveMessage message = &#123;&#125;&quot;</span>, message);</span><br><span class="line">        channel.basicAck(deliverTag, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单元测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMessageProducerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyMessageProducer myMessageProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        myMessageProducer.sendMessage(<span class="string">&quot;code_exchange&quot;</span>, <span class="string">&quot;my_routingKey&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="BI项目改造"><a href="#BI项目改造" class="headerlink" title="BI项目改造"></a>BI项目改造</h2><p>以前是任务提交到线程池，然后子啊线程池提交编写处理程序的代码，线程池内排队</p>
<p>如果程序中断了，任务就没了，就丢了</p>
<p>改造后的流程：</p>
<p>​	1.把任务提交改为向队列发送消息</p>
<p>​	2.写一个专门的接收消息的程序，处理任务</p>
<p>​	3.如果程序中断了，消息未被确认，还会重发</p>
<p>​	4.现在，消息全部集中到消息队列，可以部署多个后端，都从同一个地方取任务，从而实现分布式，负载均衡</p>
<p>验证发现，如果程序中断了，没有ack，也没有nack（服务中断，没有任何响应），那么这个消息会被重新放到消息队列中，从而实现了每个任务都会执行</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wang666-bot.github.io">Ivey</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wang666-bot.github.io/266ed923.html">https://wang666-bot.github.io/266ed923.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wang666-bot.github.io" target="_blank">Hyrule</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/wang666-bot.github.io/tags/Java%E5%BC%80%E5%8F%91-Bi%E5%88%86%E6%9E%90/">Java开发 Bi分析</a></div><div class="post_share"><div class="social-share" data-image="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fforum.gamer.com.tw%2FG2.php%3Fbsn%3D60539%26sn%3D3216&amp;psig=AOvVaw2fiuMuiGyB89xLYbvWzaYx&amp;ust=1690401754556000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CA0QjRxqFwoTCJjkxrXTqoADFQAAAAAdAAAAABAD" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/wang666-bot.github.io/51334077.html" title="伙伴匹配系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">伙伴匹配系统</div></div></a></div><div class="next-post pull-right"><a href="/wang666-bot.github.io/35f3077d.html" title="算法与数据结构学习（1）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法与数据结构学习（1）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fforum.gamer.com.tw%2FG2.php%3Fbsn%3D60539%26sn%3D3216&amp;psig=AOvVaw2fiuMuiGyB89xLYbvWzaYx&amp;ust=1690401754556000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CA0QjRxqFwoTCJjkxrXTqoADFQAAAAAdAAAAABAD" onerror="this.onerror=null;this.src='/wang666-bot.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ivey</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/wang666-bot.github.io/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/wang666-bot.github.io/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/wang666-bot.github.io/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wang666-bot"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">小王同学的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#5-25"><span class="toc-number">1.</span> <span class="toc-text">5.25</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">库表设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2"><span class="toc-number">1.2.</span> <span class="toc-text">6.2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE-%E5%BC%80%E5%8F%91%E5%89%8D%E5%87%86%E5%A4%87"><span class="toc-number">1.2.1.</span> <span class="toc-text">初始化项目-开发前准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91"><span class="toc-number">1.3.</span> <span class="toc-text">智能分析业务开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6"><span class="toc-number">1.4.</span> <span class="toc-text">6.6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AI%E6%8F%90%E9%97%AE%E6%8A%80%E5%B7%A7"><span class="toc-number">1.5.</span> <span class="toc-text">AI提问技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7"><span class="toc-number">1.6.</span> <span class="toc-text">6.7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91"><span class="toc-number">1.7.</span> <span class="toc-text">开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-17"><span class="toc-number">1.8.</span> <span class="toc-text">6.17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E7%8E%B0%E5%9C%A8%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%88%E5%8D%95%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">分析系统现在的不足（单机系统的不足）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%8F%91%E9%80%81"><span class="toc-number">1.8.2.</span> <span class="toc-text">单向发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.8.3.</span> <span class="toc-text">多消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.8.4.</span> <span class="toc-text">交换机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-18"><span class="toc-number">1.9.</span> <span class="toc-text">6.18</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#topic%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.9.1.</span> <span class="toc-text">topic交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC"><span class="toc-number">1.9.2.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Headers%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.9.3.</span> <span class="toc-text">Headers交换机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.10.</span> <span class="toc-text">核心特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.1.</span> <span class="toc-text">消息过期机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.2.</span> <span class="toc-text">消息确认机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.10.3.</span> <span class="toc-text">死信队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%EF%BC%88%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">RabbitMQ的重要特性（面试考点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-number">1.12.</span> <span class="toc-text">RabbitMQ项目实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.12.1.</span> <span class="toc-text">选择客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">1.12.2.</span> <span class="toc-text">引入依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BI%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0"><span class="toc-number">1.13.</span> <span class="toc-text">BI项目改造</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/wang666-bot.github.io/f0472f92.html" title="算法与数据结构学习（9）">算法与数据结构学习（9）</a><time datetime="2023-08-16T16:11:57.000Z" title="发表于 2023-08-17 00:11:57">2023-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/wang666-bot.github.io/48fb48f7.html" title="算法与数据结构学习（8）">算法与数据结构学习（8）</a><time datetime="2023-08-05T11:00:20.000Z" title="发表于 2023-08-05 19:00:20">2023-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/wang666-bot.github.io/41d99fe.html" title="Shader笔记-3">Shader笔记-3</a><time datetime="2023-08-03T04:52:54.000Z" title="发表于 2023-08-03 12:52:54">2023-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/wang666-bot.github.io/109858a1.html" title="算法与数据结构学习（7）">算法与数据结构学习（7）</a><time datetime="2023-08-01T13:08:12.000Z" title="发表于 2023-08-01 21:08:12">2023-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/wang666-bot.github.io/a8243fc4.html" title="算法与数据结构学习（6）">算法与数据结构学习（6）</a><time datetime="2023-07-24T13:52:05.000Z" title="发表于 2023-07-24 21:52:05">2023-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ivey</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/wang666-bot.github.io/js/utils.js"></script><script src="/wang666-bot.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/wang666-bot.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/wang666-bot.github.io/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>